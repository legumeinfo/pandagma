#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long;
use File::Basename;
use feature "say";

my $usage = <<EOS;
Given alignment of gene order with pangene IDs encoded as peptide strings,
decode these back into pangene IDs.

Usage: annot_order_decode.pl -alignment ALIGN_FILE -code_table PAN_TO_PEPTIDE_FILE  [options]
   ALIGN_FILE is a fasta file -- either a single sequence (a consensus from an alignment), 
   or a multifasta alignment file; in either case, with pseudo-peptide sequence
   corresponding with the PAN_TO_PEPTIDE_FILE hash table.

   PAN_TO_PEPTIDE_FILE, generated by make_peptide_hash.pl, has two columns:
     panID    peptide
     pan00001 FDFLS

  REQUIRED:
    -alignment  (filename) ALIGNFILE
    -code_table (filename) PAN_TO_PEPTIDE_FILE, e.g. pan_to_peptide.tsv or utilized.tsv

  OPTIONS:
    -motif_len (integer; default 5) Length of expected motif blocks, not counting Q/N separator
    -verbose   (boolean) For some debugging info, to STDOUT. Use -v -v to give more output.
    -help      (boolean) This message. 
EOS

my ($align_file, $code_table);
my $help;
my $motif_len=5;
my $verbose=0;

GetOptions (
  "align_file=s" => \$align_file,
  "code_table=s" => \$code_table,
  "motif_len:i" =>  \$motif_len,
  "verbose+" =>     \$verbose,
  "help" =>         \$help,
);

die "\n$usage\n" if ( $help || ! $align_file || ! $code_table );

my $logstr;

# Put code_table into a hash
open (my $ENC_FH, "<", $code_table) or die "Can't open in encode table: $code_table\n";
my %encode_hsh;
while (<$ENC_FH>){
  chomp;
  my ($panID, $peptide) = split(/\t/, $_);
  $encode_hsh{$peptide} = $panID;
}

# Read align_file into an array, and get count of each molecule (chromosome or scaffold.)
open (my $ALIGN_FH, "<", $align_file) or die "Can't open in align_file: $align_file\n";
my %seq_hsh;
my %seen_ID;
my $annot_ID;
while (<$ALIGN_FH>) {
  chomp;
  next unless (/^\S+/);
  my $line = $_;
  if ($line =~ /^>(\S+)/) { # defline
    $annot_ID = $1;
  }
  else { # sequence
    if ( ! $seen_ID{$annot_ID} ){
      $seen_ID{$annot_ID}++;
      $seq_hsh{$annot_ID} = $line;
    }
    else {
      $seq_hsh{$annot_ID} .= $line;
    }
  }
}

my $Xs = "x" x $motif_len;
foreach my $seqID (sort keys %seq_hsh){ 
  my $order = 1;
  my $seqstr = uc($seq_hsh{$seqID});
  my $posn = 0;
  while ( $seqstr =~ /([^QN]+)([QN])/g ){
    $posn++;
    my ($motif, $orient_char) = ($1, $2);
    $motif =~ s/X//g;
    if ( length($motif) > $motif_len ){
      $motif =~ m/(\w+)(\w{$motif_len})/;
      my $remainder = $1;
      $motif = $2;
      if ( $verbose>1 ){ warn "  XXX\t$seqID\t$remainder\tX\tREMAINDER\t$posn\n" }
      lookup_motif($seqID, $motif, $orient_char, $posn, $order);
      $order++;
    }
    elsif ( length($motif) == 0 ) {
      if ( $verbose>1 ){ warn "  XXX\t$seqID\t$Xs\t$orient_char\tGAPPY\t$posn\n" }
    }
    elsif ( length($motif) > 0 && length($motif) != $motif_len ){
      if ( $verbose>1 ){ warn "  XXX\t$seqID\t$motif\t$orient_char\tBAD_ALN\t$posn\n" }
    }
    else { # Motif at least is of the right length
      lookup_motif($seqID, $motif, $orient_char, $posn, $order);
      $order++;
    }
  }
}

sub lookup_motif{
  my ($seqID, $motif, $orient_char, $posn, $order) = @_;
  if ( defined $encode_hsh{$motif} ){
    #say "$motif\t$orient_char\t$encode_hsh{$motif}\t$posn";
    $orient_char =~ s/Q/+/;
    $orient_char =~ s/N/-/;
    my $panID = $encode_hsh{$motif};
    my $ordinal_posn = sprintf("%06d", $order*100);
    say "$panID\t$seqID\t$ordinal_posn\t$orient_char";
  }
  else {
    if ( $verbose>1 ){ warn "  XXX\t$seqID\t$motif\t$orient_char\tNO_MATCH\t$posn\n" }
  }
}

__END__
2023
S. Cannon
02-09 Initial version, based on consen_pangene_order.pl
02-03 Improve reporting of non-matches. Generate final output format.
02-22 Lower the verbosity.
