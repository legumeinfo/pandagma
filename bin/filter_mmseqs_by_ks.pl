#!/usr/bin/env perl

# PROGRAM: filter_mmseqs_by_ks.pl
# VERSION: see version notes at bottom of file.
# S. Cannon 2023
# see description under Usage

use strict;
use warnings;
use feature "say";
use Getopt::Long;
use File::Basename;
use Scalar::Util qw(looks_like_number);

my ($ks_peaks, $report_file, $verbose, $help);
my $annot_regex = '([^.]+\.[^.]+)\.\S+';
my $max_pair_ks = 4;
my $mult_for_ks_cutoff = 1.5;

GetOptions (
  "ks_peaks=s" =>    \$ks_peaks,   # required
  "annot_regex:s" => \$annot_regex,
  "max_pair_ks:f" => \$max_pair_ks,
  "mult_for_ks_cutoff:f" => \$mult_for_ks_cutoff,
  "verbose"  =>      \$verbose,
  "help" =>          \$help
);

my $scriptname = basename($0);

my $usage = <<EOS;
  Usage: cat HOMOLOGY_FILE[S] | $scriptname -ks_peaks FILE -ks_peaks FILE [-options] 
  
  Given kaks report generated by calc_ks_from_dag.pl with data fields such as the following (truncated on the right):

##GFF_A	Glycine.pan3.chr01	DAGchainer	synteny	20220001	20611000	221.0	+	.	ID=Glycine.pan3.chr01....
##GFF_B	Phaseolus.pan1.chr01	DAGchainer	synteny	1480001	1791000	221.0	+	.	ID=Phaseolus.pan1.chr01....
#%SUM	count	dag_startA	dag_stopA	dag_startB	dag_stopB	ave_Ka	ave_Ks	ave_KaKs	median_Ka	median_Ks	median_KaKs
##SUM	4	20220001	20611000	1480001	1791000	0.6907	2.8230	0.1387	0.3468	2.7445	0.1172
#%DATA	A_id	B_id	aln_len	Ka	Ks	KaKs	block_Ks
	Glycine.pan3.chr01_202200_pan01080	Phaseolus.pan1.chr01_014800_pan00566	357	0.3468	4.2412	0.08177	2.7445
	Glycine.pan3.chr01_203300_pan32537	Phaseolus.pan1.chr01_016500_pan00552	1521	0.4323	3.8798	0.11142	2.7445
	Glycine.pan3.chr01_204300_pan01089	Phaseolus.pan1.chr01_016800_pan27149	996	0.3347	2.7419	0.12207	2.7445

  ... filter gene pairs on block-median values against values provided in the file specified by -ks_peaks and
  cutoff values determined by those peak values and the supplied mult_for_ks_cutoff (default 1.5).
  
  Example1 from ks_peaks file. Column 3 is the Ks bin. Column 4 is optional. Here it contains the peak amplitude.
    sento.Myeongyun    sento.Myeongyun   0.7    1278
    sento.Myeongyun    singl.CAF01       0.75   4511
    sento.Myeongyun    vicfa.Hedin2      0.85    417
    sento.Myeongyun    Vigna.pan1        0.9    6659
    ...

  Flags and parameters:
   -ks_peaks     -- (string) File with regex for filtering on block-median Ks values, as indicated above **
   -annot_regex  -- (string) Regular expression for capturing annotation name from prefixed gene ID. Default is
                      \"([^.]+\.[^.]+)\..+\" for two dot-separated  fields from e.g. gensp.accn.gnm1.ann1.GENEID
                      In the examples above, the pattern captures "Glycine.pan3" and "Phaseolus.pan1"
   -max_pair_ks  -- (float) Maximum value for gene-pair Ks for retaining the pair. Default 4.
                      This is for individual gene pairs, and is distinct from the block-median values in the ks_peaks. 
                      This value should generally be higher than the block-median values.
   -verbose      -- (boolean) for some intermediate output to STDERR
   -help         -- (boolean) for this info
   
   ** = required
EOS

die "\n$usage\n" if ($help or !defined($ks_peaks) );

my $ANN_REX = qr/$annot_regex/;

# read in values from Ks peaks file
open( my $KS_IN, '<', $ks_peaks ) or die "can't open ks_peaks $ks_peaks: $!";
my %peaks;
while (<$KS_IN>){ # three required fields, e.g. "Arachis.pan1  Cicer.pan1  1.8"
  chomp;
  next if (/^#/ || /^$/);
  my $line = $_;
  my ($left, $right, $ks_peak_bin, $rest) = split(/\s+/);
  
  my $chr_rex;
  # Store the pattern for later regex use
  $peaks{"$left.x.$right"} = $ks_peak_bin;
  if ($verbose) {say "$left.x.$right\t$ks_peak_bin"}

  # Store the reverse pattern, if the left and right chroms are not the same
  if ($left ne $right) {
    $peaks{"$right.x.$left"} = $ks_peak_bin;
    if ($verbose) {say "$right.x.$left\t$ks_peak_bin"}
  }
}

# Process homology data, comparing to the stored ks_peak_bins
my ($QRY, $SBJ);
while (my $line = <>) {
  chomp $line;
  $line =~ s/^\t//; # Data lines begin with a tab. Strip that.
  my @parts = split(/\t/, $line);
  if ($parts[0] =~ /##GFF_A/){  # Presumes that this line preceeds the data -- which should be the case
    $parts[1] =~ /$ANN_REX/;
    $QRY = $1;
  }
  elsif ($parts[0] =~ /##GFF_B/){ # Presumes that this line preceeds the data -- which should be the case
    $parts[1] =~ /$ANN_REX/;
    $SBJ = $1;
  }
  elsif ($parts[0] =~ /^#.SUM/ || $parts[0] =~ /^#.DATA/){
    next;
  }
  elsif (scalar(@parts) != 7 && $parts[0] !~/^#/){
    warn "Unexpected line, not like a header (matching ^#) or data (with 7 fields):" . "\n" . join ("][", @parts), "\n"; 
  }
  elsif (scalar(@parts) == 7 && $parts[0] !~/^#/){
    my ($A_id, $B_id, $aln_len, $Ka, $Ks, $KaKs, $block_ks) = @parts;
    next unless (looks_like_number($Ks));
    if ($block_ks < $mult_for_ks_cutoff*$peaks{"$QRY.x.$SBJ"} && $Ks < $max_pair_ks ) {
      if ($verbose) { say join ("\t", "OK:", $QRY, $SBJ, $block_ks, "<", $mult_for_ks_cutoff*$peaks{"$QRY.x.$SBJ"}) }
      say join ("\t", @parts);
    }
    else {
      if ($verbose) { say join ("\t", "xx:", $QRY, $SBJ, $block_ks, ">=", $mult_for_ks_cutoff*$peaks{"$QRY.x.$SBJ"}) }
    }
  }
}

__END__
VERSIONS
2023-08-18 S. Cannon. Initial functional version.
2023-08-21 Add another check for conditions of data line to be processed
2023-09-05 Change variable name from ks_cutoff to ks_peaks and add mult_for_ks_cutoff
