#!/usr/bin/env perl

# PROGRAM: filter_mmseqs_by_ks.pl
# VERSION: see version notes at bottom of file.
# S. Cannon 2023
# see description under Usage

use strict;
use warnings;
use feature "say";
use Getopt::Long;
use File::Basename;
use Scalar::Util qw(looks_like_number);

my ($ks_cutoff, $report_file, $verbose, $help);
my $annot_regex = '([^.]+\.[^.]+)\.\S+';
my $max_pair_ks = 4;

GetOptions (
  "ks_cutoff=s" =>   \$ks_cutoff,   # required
  "annot_regex:s" => \$annot_regex,
  "max_pair_ks:f" => \$max_pair_ks,
  "verbose"  =>      \$verbose,
  "help" =>          \$help
);

my $scriptname = basename($0);

my $usage = <<EOS;
  Usage: cat HOMOLOGY_FILE[S] | $scriptname -ks_cutoff FILE -ks_cutoff FILE [-options] 
  
  Given kaks report generated by calc_ks_from_dag.pl with data fields such as the following (truncated on the right):

##GFF_A	Glycine.pan3.chr01	DAGchainer	synteny	20220001	20611000	221.0	+	.	ID=Glycine.pan3.chr01....
##GFF_B	Phaseolus.pan1.chr01	DAGchainer	synteny	1480001	1791000	221.0	+	.	ID=Phaseolus.pan1.chr01....
#%SUM	count	dag_startA	dag_stopA	dag_startB	dag_stopB	ave_Ka	ave_Ks	ave_KaKs	median_Ka	median_Ks	median_KaKs
##SUM	4	20220001	20611000	1480001	1791000	0.6907	2.8230	0.1387	0.3468	2.7445	0.1172
#%DATA	A_id	B_id	aln_len	Ka	Ks	KaKs	block_Ks
	Glycine.pan3.chr01_202200_pan01080	Phaseolus.pan1.chr01_014800_pan00566	357	0.3468	4.2412	0.08177	2.7445
	Glycine.pan3.chr01_203300_pan32537	Phaseolus.pan1.chr01_016500_pan00552	1521	0.4323	3.8798	0.11142	2.7445
	Glycine.pan3.chr01_204300_pan01089	Phaseolus.pan1.chr01_016800_pan27149	996	0.3347	2.7419	0.12207	2.7445

  ... filter gene pairs on block-median values against cutoff values provided in the file specified by -ks_cutoff
  
  Example1 from ks_cutoff file ...
    Cicer.pan1  Cicer.pan1     1.43
    Cicer.pan1  Glycine.pan3   1.28
    ...
    Glycine.pan3	Phaseolus.pan1	1.13
    ...

  Flags and parameters:
   -ks_cutoff    -- (string) File with regex for filtering on block-median Ks values, as indicated above **
   -annot_regex  -- (string) Regular expression for capturing annotation name from prefixed gene ID. Default is
                      \"([^.]+\.[^.]+)\..+\" for two dot-separated  fields from e.g. gensp.accn.gnm1.ann1.GENEID
                      In the examples above, the pattern captures "Glycine.pan3" and "Phaseolus.pan1"
   -max_pair_ks  -- (float) Maximum value for gene-pair Ks for retaining the pair. Default 4.
                      This is for individual gene pairs, and is distinct from the block-median values in the ks_cutoff. 
                      This value should generally be higher than the block-median values.
   -verbose      -- (boolean) for some intermediate output to STDERR
   -help         -- (boolean) for this info
   
   ** = required
EOS

die "\n$usage\n" if ($help or !defined($ks_cutoff) );

my $ANN_REX = qr/$annot_regex/;

# read in values from Ks cutoff file
open( my $KS_IN, '<', $ks_cutoff ) or die "can't open ks_cutoff $ks_cutoff: $!";
my %cutoffs;
while (<$KS_IN>){ # three fields, e.g. "Arachis.pan1  Cicer.pan1  1.8"
  chomp;
  next if (/^#/ || /^$/);
  my $line = $_;
  my ($left, $right, $threshold) = split(/\s+/);
  
  my $chr_rex;
  # Store the pattern for later regex use
  $cutoffs{"$left.x.$right"} = $threshold;
  if ($verbose) {say "$left.x.$right\t$threshold"}

  # Store the reverse pattern, if the left and right chroms are not the same
  if ($left ne $right) {
    $cutoffs{"$right.x.$left"} = $threshold;
    if ($verbose) {say "$right.x.$left\t$threshold"}
  }
}

# Process homology data, comparing to the stored thresholds
my ($QRY, $SBJ);
while (my $line = <>) {
  chomp $line;
  $line =~ s/^\t//; # Data lines begin with a tab. Strip that.
  my @parts = split(/\t/, $line);
  if ($parts[0] =~ /##GFF_A/){  # Presumes that this line preceeds the data -- which should be the case
    $parts[1] =~ /$ANN_REX/;
    $QRY = $1;
  }
  elsif ($parts[0] =~ /##GFF_B/){ # Presumes that this line preceeds the data -- which should be the case
    $parts[1] =~ /$ANN_REX/;
    $SBJ = $1;
  }
  elsif ($parts[0] =~ /^#.SUM/ || $parts[0] =~ /^#.DATA/){
    next;
  }
  elsif (scalar(@parts) != 7 && $parts[0] !~/^#/){
    warn "Unexpected line, not like a header (matching ^#) or data (with 7 fields):" . "\n" . join ("][", @parts), "\n"; 
  }
  elsif (scalar(@parts) == 7 && $parts[0] !~/^#/){
    my ($A_id, $B_id, $aln_len, $Ka, $Ks, $KaKs, $block_ks) = @parts;
    next unless (looks_like_number($Ks));
    if ($block_ks < $cutoffs{"$QRY.x.$SBJ"} && $Ks < $max_pair_ks ) {
      if ($verbose) { say join ("\t", "OK:", $QRY, $SBJ, $block_ks, "<", $cutoffs{"$QRY.x.$SBJ"}) }
      say join ("\t", @parts);
    }
    else {
      if ($verbose) { say join ("\t", "xx:", $QRY, $SBJ, $block_ks, ">=",  $cutoffs{"$QRY.x.$SBJ"}) }
    }
  }
}

__END__
VERSIONS
2023-08-18 S. Cannon. Initial functional version.
2023-08-21 Add another check for conditions of data line to be processed
