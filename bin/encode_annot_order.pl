#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long;
use List::Util qw(sum);
use File::Basename;
use Data::Dumper;
use feature "say";
my $PROGRAM_NAME = basename($0);

my $usage = <<EOS;
Given five-column input (pan-IDs, gene_IDs, annot.chr#, start, end), 
Produce chromosome multifasta files, with a representation of gene order per annotation.
Gene order is coded as a set of unique peptide strings that can be aligned using a 
standard protein multiple alignment program.

Usage: encode_annot_order.pl -pan_table PANGENE_TABLE -code_table PAN_TO_PEPTIDE_FILE  [options]
   PANGENE_TABLE input has five columns:
     panID  geneID  chr  annot.chr  start  end

   PAN_TO_PEPTIDE_FILE, generated by make_peptide_hash.pl, has two columns:
     panID    peptide
     pan00001 ADWTL

  REQUIRED:
    -pan_table  PANGENE_TABLE, e.g. *_posn.hsh.tsv
    -code_table PAN_TO_PEPTIDE_FILE, e.g. pan_to_peptide.tsv

  OPTIONS:
    -outdir   Directory where files will be written [default "."]
    -verbose  For some debugging info, to STDOUT. Use -v -v to give more output.
    -help     This message. 
EOS

my ($pan_table, $code_table);
my $help;
my $outdir=".";
my $verbose=0;

GetOptions (
  "pan_table=s" => \$pan_table,
  "code_table=s" => \$code_table,
  "outdir:s" =>   \$outdir,
  "verbose+" =>    \$verbose,
  "help" =>        \$help,
);

die "\n$usage\n" if ( $help || ! $pan_table || ! $code_table );

my $logstr;

# Put code_table into a hash
open (my $ENC_FH, "<", $code_table) or die "Can't open in encode table: $code_table\n";
my %encode_hsh;
while (<$ENC_FH>){
  chomp;
  my ($key, $val) = split(/\t/, $_);
  $encode_hsh{$key} = $val;
}

# Read pan_table into an array, and get count of each molecule (chromosome or scaffold.)
open (my $PAN_FH, "<", $pan_table) or die "Can't open in pan_table: $pan_table\n";
my %count_pepID_chr;
my %HoH_pepID_chr;
my @pangene_table;
while (<$PAN_FH>) {
  chomp;
  next unless (/^\S+/);
  my $line = $_;
  my ($panID, $gene, $ann_chr, $start, $end) = split(/\t/, $line);

  # Encode the panID as a peptide
  my $pepID = $encode_hsh{$panID};

  # From the second feeld (prefixed genes), extract the annot name
  my $annot_str_regex = "([^.]+\.[^.]+\.[^.]+\.[^.]+)\..+";  # TO DO: Take as parameter
  #my $annot_str_regex = "(\D+\d+\D+)\d+.+";  # TO DO: Take as parameter
  my $ANN_REX = $annot_str_regex;
  my $ann = $gene;
  $ann =~ s/$ANN_REX/$1/;

  # From the third field, a annot.chr string, extract chr
  $ann_chr =~ /\S+\.(\D+\w+\D+)(\d+)$/;
  my ($chr_pre, $chr) = ($1, $2, $3);
  if ( !defined $chr_pre || !defined $chr ){
    if ($verbose){ say "For pan-gene consensus, skipping unrecognized annotation-prefix-chr pattern: $ann_chr" }
    next;
  }
  $chr_pre =~ s/[_.]$//;
  # Next: skip genes on scaffolds and other non-chromosome molecules
  if ( $chr_pre =~ /chloro|chl|CP|mito|MT|ctg|contig|tig|pilon|scaff|sc|super|un\w+\d+/i ){
    if ($verbose){ say "For pan-gene consensus, skipping non-chromosome gene [$chr_pre $chr]\t$gene" }
  }
  else {
    $chr =~ s/^0*([^0]+)/$1/;
    #say "A:\t($pepID, $gene, $ann, $chr_pre, $chr)";
    $HoH_pepID_chr{$pepID}{$chr}++;
    my @six_elts = ( $pepID, $gene, $ann, $chr, $start, $end );
    push( @pangene_table, \@six_elts );
  }
}

# Sort @pangene_table to determine order per (1) annot; (2) chromosome; (3) posn
my @sorted_table = sort { 
     $a->[2] cmp $b->[2] || $a->[3] <=> $b->[3] || $a->[4] <=> $b->[4] 
   } @pangene_table; 

# Calculate gene order per annot-and-chromosome
my ($prAnn, $prChr) = ("", "");
my $ord=0;
my @elts_with_order;
my @pangene_table_ordered;
my %seen_chr;
foreach my $row ( @sorted_table ) {
  my ($pepID, $gene, $ann, $chr, $start, $end) = @$row;
  #say join("\t", "AA: ", $pepID, $gene, $ann, $chr, $start, $end);
  unless ( $seen_chr{$chr} ){ $seen_chr{$chr}++ }
  if ($ann eq $prAnn && $chr == $prChr){
    $ord++;
    @elts_with_order = ( $pepID, $ann, $chr, $ord, $start, $end );
    push ( @pangene_table_ordered, [@elts_with_order] );
    #say join("\t", @elts_with_order);
    ($prAnn, $prChr) = ($ann, $chr);
  }
  elsif ($ann ne $prAnn || $chr != $prChr){
    $ord=1;
    @elts_with_order = ( $pepID, $ann, $chr, $ord, $start, $end );
    push ( @pangene_table_ordered, [@elts_with_order] );
    #say join("\t", @elts_with_order);
    ($prAnn, $prChr) = ($ann, $chr);
    $ord++;
  }
}
my $num_chrs = keys %seen_chr;
#say "CHROMOSOMES: $num_chrs";

# Find the most frequent chromosome for each pan-gene set
my %top_chr;
my %chr_ct_top_chr;
if ($verbose>1) {print "#pangeneID\tchr:count ...\n"}
foreach my $pepID (sort keys %HoH_pepID_chr) {
  if ($verbose>1){ $logstr .= "$pepID\t" }
  # Sort chromosomes by count of chromosomes seen for this pepID
  foreach my $chr ( sort { $HoH_pepID_chr{$pepID}{$b} <=> $HoH_pepID_chr{$pepID}{$a} } 
                            keys %{$HoH_pepID_chr{$pepID}} ) {
    my $chr_ct = $HoH_pepID_chr{$pepID}{$chr};
    # Store first chromosome (most frequent), and the number of times it was seen.
    unless ($top_chr{$pepID}){ 
      $top_chr{$pepID} = $chr; 
      $chr_ct_top_chr{$pepID} = $chr_ct;
    }
    if ($verbose>1){ $logstr .= "$chr:$chr_ct " }
  }
  if ($verbose>1){ $logstr .= "\n" }
}
if ($verbose>1){ print "$logstr\n" }

if ($verbose>1) {print "#pangeneID\ttop_chr:count\n"}
foreach my $pepID (sort keys %top_chr) {
  if ($verbose>1){ printf "%s\t%s:%s\n", $pepID, $top_chr{$pepID}, $chr_ct_top_chr{$pepID} }
}
if ($verbose>1) {print "\n"}

#say Dumper(\@pangene_table_ordered);

# Construct encoded chromosome strings and put into arrays by chromosome and annotation set
%seen_chr = ();
my %seen_ann_chr;
my %encoded_order_ID;
my %encoded_order_seq;
foreach my $row ( @pangene_table_ordered ) {
  my ( $pepID, $ann, $chr, $order, $start, $end ) = @$row;
  my $chr_str = sprintf("chr%02d", $chr);
  my $pepIDQ = "$pepID" . "Q"; # TO DO: Register order with this letter, using Q or N
  #say join("\t", $chr_str, $ann, $order, $start, $end, $pepIDQ);
  if (! $seen_chr{$chr_str}){
    $seen_chr{$chr_str}++;
    my $ann_chr = "$ann.$chr_str";
    if (! $seen_ann_chr{$ann_chr}){
      #say "  >$ann_chr";
      $seen_ann_chr{$chr_str}{$ann}++;
      $encoded_order_ID{$chr_str}{$ann} = $ann_chr;
      $encoded_order_seq{$chr_str}{$ann} = "$pepIDQ";
    }
    else {
      $encoded_order_seq{$chr_str}{$ann} .= "$pepIDQ";
    }
  }
  else {
    my $ann_chr = "$ann.$chr_str";
    if (! $seen_ann_chr{$chr_str}{$ann}){
      #say "  >$ann_chr";
      $seen_ann_chr{$chr_str}{$ann}++;
      $encoded_order_ID{$chr_str}{$ann} = $ann_chr;
      $encoded_order_seq{$chr_str}{$ann} = "$pepIDQ";
    }
    else {
      $encoded_order_seq{$chr_str}{$ann} .= "$pepIDQ";
    }
  }
}

# Print to multifasta files of chromosomes by annotation
foreach my $chr_str (sort keys %seen_chr){
  if ($verbose){say "Printing to $chr_str";}
  open (my $OUTFH, ">", "$outdir/$chr_str") or die "Can't open out encoded chromosome file: $outdir/$chr_str\n";
  foreach my $ann (sort keys %{ $encoded_order_ID{$chr_str} } ){
    my $encoded_order = $encoded_order_seq{$chr_str}{$ann};
    my @chunks = ( $encoded_order =~ m/.{100}/g );
    say $OUTFH ">$ann ";
    say $OUTFH join ("\n", @chunks);
  }
}

#say Dumper(\%encoded_order_ID);
#say "";
#say Dumper(\%encoded_order_seq);

##################################################
# SUBRUTINES

# Return median value for an array of numbers
# See http://stackoverflow.com/questions/5119034/using-perl-to-find-median-mode-standard-deviation
sub calc_median {
  my $value_ref = shift;
  my @values = @$value_ref;
  my $median;
  my $mid = int ((scalar @values)/2);
  my @sorted_values = sort {$a <=> $b} @values;
  if (@values % 2) {
    $median = $sorted_values[ $mid ];
  } else {
    $median = ($sorted_values[$mid-1] + $sorted_values[$mid])/2;
  } 
  return $median;
}

__END__
2023
S. Cannon
02-09 Initial version, based on consen_pangene_order.pl
02-10 Get full annotation name rather than just gensp.genotype.gnm prefix
