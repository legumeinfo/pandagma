#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long;
use List::Util qw(sum);
use File::Basename;
use Data::Dumper;
use feature "say";
my $PROGRAM_NAME = basename($0);

my $usage = <<EOS;
Given alignment of gene order with pangene IDs encoded as peptide strings,
decode these back into pangene IDs.

Usage: decode_annot_order.pl -alignment ALIGN_FILE -code_table PAN_TO_PEPTIDE_FILE  [options]
   ALIGN_FILE is a standard multifasta alignment file, with pseudo-peptide sequence
   corresponding with the PAN_TO_PEPTIDE_FILE hash table.

   PAN_TO_PEPTIDE_FILE, generated by make_peptide_hash.pl, has two columns:
     panID    peptide
     pan00001 IVWFS

  REQUIRED:
    -alignment  ALIGNFILE
    -code_table PAN_TO_PEPTIDE_FILE, e.g. pan_to_peptide.tsv

  OPTIONS:
    -outdir  Specify directory where files will be written [default "."]
    -verbose  For some debugging info, to STDOUT. Use -v -v to give more output.
    -help     This message. 
EOS

my ($align_file, $code_table);
my $help;
my $outdir=".";
my $verbose=0;

GetOptions (
  "align_file=s" => \$align_file,
  "code_table=s" => \$code_table,
  "outdir:s" =>   \$outdir,
  "verbose+" =>    \$verbose,
  "help" =>        \$help,
);

die "\n$usage\n" if ( $help || ! $align_file || ! $code_table );

my $logstr;

# Put code_table into a hash
open (my $ENC_FH, "<", $code_table) or die "Can't open in encode table: $code_table\n";
my %encode_hsh;
while (<$ENC_FH>){
  chomp;
  my ($panID, $peptide) = split(/\t/, $_);
  $encode_hsh{$peptide} = $panID;
}

# Read align_file into an array, and get count of each molecule (chromosome or scaffold.)
open (my $ALIGN_FH, "<", $align_file) or die "Can't open in align_file: $align_file\n";
my %seq_hsh;
my %seen_ID;
my $annot_ID;
while (<$ALIGN_FH>) {
  chomp;
  next unless (/^\S+/);
  my $line = $_;
  if ($line =~ /^>(\S+)/) { # defline
    $annot_ID = $1;
  }
  else { # sequence
    if ( ! $seen_ID{$annot_ID} ){
      $seen_ID{$annot_ID}++;
      $seq_hsh{$annot_ID} = $line;
    }
    else {
      $seq_hsh{$annot_ID} .= $line;
    }
  }
}

foreach my $seqID (sort keys %seq_hsh){ 
  say "\n==========\n$seqID";
  my $seqstr = $seq_hsh{$seqID};
  $seqstr =~ s/-+//g;
  my @peptides = split(/Q|N/, $seqstr);
  for my $pep (@peptides){
    say "$pep\t$encode_hsh{$pep}";
  }
}

__END__
2023
S. Cannon
02-09 Initial version, based on consen_pangene_order.pl

